---
title: Setup
description: Configure the Reclaim Browser Extension SDK in your web application
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

## Prerequisites

- ✅ [Installation guide](/browser-extension/installation) completed
- ✅ [API credentials](/api-key) obtained
- ✅ Extension ID of the Reclaim-compatible extension
- ✅ Web application (React, Vue, vanilla JS)

## Installation

<Tabs items={['npm', 'yarn']}>
```bash tab="npm"
npm install @reclaimprotocol/browser-extension-sdk
```

```bash tab="yarn"
yarn add @reclaimprotocol/browser-extension-sdk
```
</Tabs>

## Environment Variables

Create `.env.local` in your project root:

<Tabs items={['Vite', 'Create React App', 'Next.js']}>
```bash tab="Vite"
VITE_RECLAIM_APP_ID=your_application_id
VITE_RECLAIM_APP_SECRET=your_secret  # Dev only!
VITE_RECLAIM_EXTENSION_ID=extension_id
```

```bash tab="Create React App"
REACT_APP_RECLAIM_APP_ID=your_application_id
REACT_APP_RECLAIM_APP_SECRET=your_secret  # Dev only!
REACT_APP_RECLAIM_EXTENSION_ID=extension_id
```

```bash tab="Next.js"
NEXT_PUBLIC_RECLAIM_APP_ID=your_application_id
RECLAIM_APP_SECRET=your_secret  # Server-side only
NEXT_PUBLIC_RECLAIM_EXTENSION_ID=extension_id
# NEVER put secret in NEXT_PUBLIC_ variables
```
</Tabs>

<Callout type="warning">
**Security**: Never commit `.env.local` to version control. Add to `.gitignore`:
```bash
.env.local
.env.*.local
```
</Callout>

## Quick Start Setup (Development Only)

For rapid prototyping and development, you can initialize verification directly with credentials.

<Callout type="warning">
**Development Only**: This approach exposes your application secret in client-side code. Only use for development and testing. Never deploy to production with this method.
</Callout>

### Vanilla JavaScript

```javascript
import { reclaimExtensionSDK } from "@reclaimprotocol/browser-extension-sdk";

const APP_ID = import.meta.env.VITE_RECLAIM_APP_ID;
const APP_SECRET = import.meta.env.VITE_RECLAIM_APP_SECRET; // Dev only!
const EXTENSION_ID = import.meta.env.VITE_RECLAIM_EXTENSION_ID;

async function initializeVerification(providerId) {
  try {
    // Initialize with extension ID
    const request = await reclaimExtensionSDK.init(
      APP_ID,
      APP_SECRET,
      providerId,
      {
        extensionID: EXTENSION_ID
      }
    );

    // Set up event handlers
    request.on("completed", (proofs) => {
      console.log("Verification completed:", proofs);
      // Handle proofs
    });

    request.on("error", (error) => {
      console.error("Verification error:", error);
      // Handle error
    });

    // Start verification
    await request.startVerification();

  } catch (error) {
    console.error("Failed to initialize:", error);
  }
}

// Use it
initializeVerification("google-login");
```

### React Example

```javascript
import { useState } from "react";
import { reclaimExtensionSDK } from "@reclaimprotocol/browser-extension-sdk";

function ReclaimVerification() {
  const [proofs, setProofs] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  const APP_ID = import.meta.env.VITE_RECLAIM_APP_ID;
  const APP_SECRET = import.meta.env.VITE_RECLAIM_APP_SECRET; // Dev only!
  const EXTENSION_ID = import.meta.env.VITE_RECLAIM_EXTENSION_ID;

  const handleVerification = async () => {
    setLoading(true);
    setError(null);

    try {
      const request = await reclaimExtensionSDK.init(
        APP_ID,
        APP_SECRET,
        "google-login",
        {
          extensionID: EXTENSION_ID
        }
      );

      request.on("completed", (proofs) => {
        console.log("Proofs:", proofs);
        setProofs(proofs);
        setLoading(false);
      });

      request.on("error", (err) => {
        console.error("Error:", err);
        setError(err.message || String(err));
        setLoading(false);
      });

      await request.startVerification();

    } catch (err) {
      setError(err.message || String(err));
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={handleVerification} disabled={loading}>
        {loading ? "Verifying..." : "Verify with Reclaim"}
      </button>

      {error && <div style={{ color: "red" }}>Error: {error}</div>}

      {proofs && (
        <div>
          <h3>Verification Successful!</h3>
          <pre>{JSON.stringify(proofs, null, 2)}</pre>
        </div>
      )}
    </div>
  );
}

export default ReclaimVerification;
```


## Production Setup (Recommended)

<Callout type="warning">
**🔒 Production Security Best Practice**

For production deployments, **generate verification requests on your backend** instead of exposing credentials in client-side code.

**Why this approach:**
- ✅ **Keeps secrets secure** - `APP_ID` and `APP_SECRET` stay on your server
- ✅ **Server-side validation** - You control who can request verification
- ✅ **No credential exposure** - Users can't extract secrets from browser dev tools
- ✅ **Better security** - Add authentication, rate limiting, logging

**What you'll use:**
- Backend: `@reclaimprotocol/js-sdk` (different package with server-side features)
- Frontend: `@reclaimprotocol/browser-extension-sdk` (just receives config from backend)

📖 **Full Backend Setup Guide**: [Backend Usage Documentation](/web/backend/usage#3-create-the-proof-request-generator-endpoint)
</Callout>

### Install Backend SDK

First, install the backend SDK on your server:

```bash
npm install @reclaimprotocol/js-sdk
```

### Backend API Setup

Create an API endpoint that generates verification requests:

#### Node.js / Express

```javascript
import express from "express";
// Backend SDK - different from browser-extension-sdk
import { ReclaimProofRequest } from "@reclaimprotocol/js-sdk";

const app = express();
app.use(express.json());

app.post("/api/verification/create", async (req, res) => {
  try {
    const { userId, providerId } = req.body;

    // Validate user (your authentication logic)
    if (!req.user || req.user.id !== userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }

    // Validate provider
    if (!isValidProvider(providerId)) {
      return res.status(400).json({ error: "Invalid provider" });
    }

    // Create request using @reclaimprotocol/js-sdk
    // Credentials stay secure on server
    const reclaimRequest = await ReclaimProofRequest.init(
      process.env.RECLAIM_APP_ID,      // Secure on server
      process.env.RECLAIM_APP_SECRET,   // Never sent to client
      providerId
    );

    // Get configuration (no secrets included)
    const requestConfig = await reclaimRequest.toJSON();

    // Return safe config to client
    res.json({ requestConfig });

  } catch (error) {
    console.error("Failed to create verification:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/api/verification/validate", async (req, res) => {
  try {
    const { proofs } = req.body;

    // Validate proofs server-side
    const isValid = await validateProofs(proofs);

    if (isValid) {
      // Store verification result, update user status, etc.
      await updateUserVerification(req.user.id, proofs);

      res.json({ success: true, verified: true });
    } else {
      res.json({ success: false, verified: false });
    }

  } catch (error) {
    console.error("Validation error:", error);
    res.status(500).json({ error: "Validation failed" });
  }
});

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
```

#### Next.js API Routes

```javascript
// pages/api/verification/create.js
// Backend SDK - different from browser-extension-sdk
import { ReclaimProofRequest } from "@reclaimprotocol/js-sdk";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { providerId } = req.body;

    // Your authentication check
    // const user = await getUser(req);
    // if (!user) return res.status(401).json({ error: "Unauthorized" });

    // Create request using @reclaimprotocol/js-sdk
    const reclaimRequest = await ReclaimProofRequest.init(
      process.env.RECLAIM_APP_ID,      // Secure on server
      process.env.RECLAIM_APP_SECRET,   // Never sent to client
      providerId
    );

    const requestConfig = await reclaimRequest.toJSON();

    res.status(200).json({ requestConfig });

  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ error: error.message });
  }
}
```

```javascript
// pages/api/verification/validate.js
export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const { proofs } = req.body;

    // Validate proofs
    const isValid = await validateProofs(proofs);

    if (isValid) {
      // Store results, update user, etc.
      res.status(200).json({ success: true, verified: true });
    } else {
      res.status(400).json({ success: false, verified: false });
    }

  } catch (error) {
    console.error("Validation error:", error);
    res.status(500).json({ error: error.message });
  }
}
```

### Frontend Integration with Server Config

```javascript
// Frontend uses browser-extension-sdk (NOT js-sdk)
import { reclaimExtensionSDK } from "@reclaimprotocol/browser-extension-sdk";

const EXTENSION_ID = import.meta.env.VITE_RECLAIM_EXTENSION_ID;

async function startVerificationWithServerConfig(providerId) {
  try {
    // Fetch config from YOUR backend (no secrets in frontend)
    const response = await fetch("/api/verification/create", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify({ providerId })
    });

    if (!response.ok) {
      throw new Error("Failed to create verification");
    }

    const { requestConfig } = await response.json();

    // Initialize with backend config (no secrets needed here)
    const request = reclaimExtensionSDK.fromConfig(requestConfig, {
      extensionID: EXTENSION_ID
    });

    request.on("completed", async (proofs) => {
      // Send proofs to backend for validation
      await validateProofsOnServer(proofs);
    });

    request.on("error", (error) => {
      console.error("Verification failed:", error);
    });

    await request.startVerification();

  } catch (error) {
    console.error("Error:", error);
  }
}

async function validateProofsOnServer(proofs) {
  try {
    const response = await fetch("/api/verification/validate", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${getAuthToken()}`
      },
      body: JSON.stringify({ proofs })
    });

    const result = await response.json();

    if (result.verified) {
      console.log("✅ Verification successful!");
      // Update UI, redirect, etc.
    } else {
      console.log("❌ Verification failed");
    }

  } catch (error) {
    console.error("Validation error:", error);
  }
}
```

<Callout type="info">
**Benefits Summary:**
- 🔐 Credentials never leave your server
- ✅ You control authorization (who can verify)
- 🛡️ Server validates proofs before accepting
- 📊 Track usage, add rate limits, log events
- 🚀 Update verification logic without website updates

See [Backend SDK Documentation](/web/backend/usage) for complete backend setup guide.
</Callout>

## Checking Extension Installation

Before starting verification, check if the extension is installed:

```javascript
import { reclaimExtensionSDK } from "@reclaimprotocol/browser-extension-sdk";

const EXTENSION_ID = import.meta.env.VITE_RECLAIM_EXTENSION_ID;

async function checkExtensionInstalled() {
  try {
    const isInstalled = await reclaimExtensionSDK.isExtensionInstalled({
      extensionID: EXTENSION_ID
    });

    if (isInstalled) {
      console.log("✅ Extension is installed");
      return true;
    } else {
      console.log("❌ Extension not installed");
      return false;
    }

  } catch (error) {
    console.error("Error checking extension:", error);
    return false;
  }
}

// Use before verification
async function handleVerifyClick() {
  const installed = await checkExtensionInstalled();

  if (!installed) {
    showInstallExtensionPrompt();
    return;
  }

  // Proceed with verification
  startVerification();
}
```

### React Component with Installation Check

```javascript
import { useState, useEffect } from "react";
import { reclaimExtensionSDK } from "@reclaimprotocol/browser-extension-sdk";

function ReclaimVerificationWithCheck() {
  const [extensionInstalled, setExtensionInstalled] = useState(null);
  const EXTENSION_ID = import.meta.env.VITE_RECLAIM_EXTENSION_ID;

  useEffect(() => {
    checkExtension();
  }, []);

  const checkExtension = async () => {
    const installed = await reclaimExtensionSDK.isExtensionInstalled({
      extensionID: EXTENSION_ID
    });
    setExtensionInstalled(installed);
  };

  if (extensionInstalled === null) {
    return <div>Checking extension...</div>;
  }

  if (!extensionInstalled) {
    return (
      <div>
        <p>Reclaim extension is required for verification.</p>
        <a
          href="https://chrome.google.com/webstore"
          target="_blank"
          rel="noopener noreferrer"
        >
          Install Extension
        </a>
        <button onClick={checkExtension}>Check Again</button>
      </div>
    );
  }

  return (
    <div>
      <button onClick={handleVerification}>
        Verify with Reclaim
      </button>
    </div>
  );
}
```

## Next Steps

With setup complete, learn how to implement verification flows:

**[Implement Verification →](/browser-extension/web-integration/usage)**
